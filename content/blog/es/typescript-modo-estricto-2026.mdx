---
title: "El Modo Estricto de TypeScript Gan√≥ ‚Äî As√≠ es Como Usarlo Bien"
slug: typescript-modo-estricto-2026
description: "TypeScript es ahora el lenguaje #1 en GitHub. Aprende la configuraci√≥n tsconfig de m√°xima rigurosidad para 2026, patrones de producci√≥n y c√≥mo migrar incrementalmente."
date: 2026-02-18
author: mario-ayala
locale: es
category: Programaci√≥n
subject: web-development
tags: ["TypeScript", "Modo Estricto", "Mejores Pr√°cticas", "tsconfig", "Calidad de C√≥digo"]
featured: true
draft: false
translationSlug: typescript-strict-mode-2026
---

**La dominancia de TypeScript ya no admite debate: es el lenguaje m√°s utilizado en GitHub, se acerca a representar la mayor√≠a del ecosistema JavaScript, y su compilador pronto vendr√° con el strict mode habilitado por defecto.** La encuesta State of JavaScript 2025, publicada en febrero de 2026, encontr√≥ que **el 40% de los encuestados ya programa exclusivamente en TypeScript** ‚Äî una cifra que los organizadores de la encuesta describen como que "sigue aumentando y pronto podr√≠a representar una mayor√≠a." Daniel Roe, l√≠der del equipo de Nuxt, declar√≥ en las conclusiones de la encuesta: "TypeScript ha ganado. No como bundler ‚Äî sino como lenguaje." Un d√≠a despu√©s, el equipo de TypeScript anunci√≥ la **beta de TypeScript 6.0**, el √∫ltimo lanzamiento basado en JavaScript antes de que el TypeScript 7.0, construido en Go, entregue mejoras de velocidad de compilaci√≥n de 10x. Esta convergencia ‚Äî dominio del ecosistema, soporte nativo en Node.js, y una revoluci√≥n de rendimiento ‚Äî convierte la seguridad de tipos estricta no en un lujo, sino en la pr√°ctica definitoria que separa un TypeScript de nivel producci√≥n de una falsa sensaci√≥n de seguridad.

Esta gu√≠a combina los datos m√°s recientes de las encuestas, cada flag del compilador que deber√≠as habilitar, patrones probados en producci√≥n, y un argumento respaldado por datos de que el ascenso de TypeScript y la seguridad de tipos estricta son inseparables.

---

## Los datos que prueban la dominancia de TypeScript son abrumadores

La evidencia abarca todas las encuestas principales de desarrolladores realizadas en 2024 y 2025. El informe **GitHub Octoverse 2025** registr√≥ el cambio de lenguaje m√°s significativo en m√°s de una d√©cada: TypeScript se convirti√≥ en el **lenguaje #1 en GitHub por contribuyentes mensuales** en agosto de 2025, con **2.64 millones de contribuyentes mensuales** ‚Äî un aumento interanual del **66.6%** que super√≥ incluso a Python. La encuesta **State of JavaScript 2024** (~23,500 encuestados) encontr√≥ que **el 67% de los desarrolladores escribe m√°s TypeScript que JavaScript** y **el 80% escribe al menos la mitad de su c√≥digo en TypeScript**. La encuesta **State of JavaScript 2025** (~12,000 encuestados) escal√≥ la tendencia: **el 40% ahora escribe solo TypeScript**, frente al 34% del a√±o anterior.

La encuesta **JetBrains Developer Ecosystem 2024** clasific√≥ a TypeScript como **#1 en su nuevo "Language Promise Index"** ‚Äî una m√©trica compuesta de crecimiento a cinco a√±os, intenci√≥n de adopci√≥n y retenci√≥n de usuarios ‚Äî por delante de Rust y Python. La encuesta de Stack Overflow de 2024 situ√≥ el uso de TypeScript en un **38.5% entre todos los desarrolladores** y **43.4% entre los profesionales**, clasific√°ndolo en quinto lugar a nivel global, pero primero entre los lenguajes que no preceden a la web. Mientras tanto, el compilador de TypeScript registra **m√°s de 60 millones de descargas semanales en npm**, el triple de la cifra de 2021.

La conexi√≥n entre esta dominancia y la tipificaci√≥n estricta es inferencial pero s√≥lida. Las encuestas State of JavaScript han preguntado sobre los mayores puntos de dolor de JavaScript todos los a√±os desde 2020, y la respuesta nunca ha cambiado: **"la falta de un sistema de tipos integrado" es la queja #1 cada a√±o sin excepci√≥n**. Un estudio acad√©mico de 2025 encontr√≥ que **el 94% de los errores de compilaci√≥n generados por LLMs son fallos de verificaci√≥n de tipos**, lo que explica directamente por qu√© el informe Octoverse de GitHub vincula el auge de TypeScript con la programaci√≥n asistida por IA ‚Äî los tipos act√∫an como barandillas que hacen que Copilot y herramientas similares sean dram√°ticamente m√°s confiables. Todos los frameworks principales generan TypeScript con `strict: true` por defecto: Next.js 15, Angular 18, SvelteKit 2, Astro 3, Remix, SolidStart y Qwik.

**Resumen de datos clave de las encuestas:**

| Fuente | A√±o | Muestra | M√©trica clave de TypeScript |
|---|---|---|---|
| State of JS 2025 | 2025 | ~12,000 | 40% programa solo en TS; "TypeScript ha ganado" |
| State of JS 2024 | 2024 | ~23,500 | 67% escribe m√°s TS que JS; 80%+ al menos la mitad en TS |
| GitHub Octoverse | 2025 | Toda la plataforma | Lenguaje #1 por contribuyentes (2.64M, +66.6% interanual) |
| Stack Overflow | 2024 | 65,437 | 38.5% todos los devs; 43.4% profesionales |
| JetBrains DevEco | 2024 | 23,262 | #1 Language Promise Index; 35% todos los devs |

La encuesta State of JavaScript 2025 tambi√©n revel√≥ fricciones a nivel de ecosistema relevantes para esta discusi√≥n. **Webpack**, utilizado por el 86% de los encuestados, genera **rechazo en el 37%** ‚Äî calificado como "una pesadilla absoluta para configurar." **Next.js**, utilizado por el 59%, acumula quejas sobre su dependencia de Vercel y su creciente complejidad. **Vite**, en contraste, obtuvo un **56% de sentimiento positivo** con un 84% de uso, y Daniel Roe declar√≥ que 2026 es "el a√±o para pasarse a Vite." Estos cambios del ecosistema refuerzan la centralidad de TypeScript: el debate sobre herramientas se ha desplazado hacia los bundlers y meta-frameworks, mientras que la cuesti√≥n del lenguaje est√° resuelta.

---

## Lo que `strict: true` realmente habilita ‚Äî y por qu√© no es suficiente

El flag `strict` en `tsconfig.json` es un atajo para nueve opciones del compilador individuales. A partir de TypeScript 5.6, habilitar `"strict": true` activa lo siguiente:

**`strictNullChecks`** (TS 2.0) trata `null` y `undefined` como tipos distintos, previniendo el "error de los mil millones de d√≥lares" de los errores de referencia nula. **`noImplicitAny`** (TS 1.0) genera un error cuando TypeScript infiere `any` para par√°metros sin tipo. **`strictFunctionTypes`** (TS 2.6) impone verificaci√≥n de par√°metros contravariante ‚Äî una funci√≥n que espera `MouseEvent` no aceptar√° silenciosamente una que espera `Event`. **`strictBindCallApply`** (TS 3.2) verifica los tipos de los argumentos de `bind`, `call` y `apply`. **`strictPropertyInitialization`** (TS 2.7) requiere que las propiedades de clase sean inicializadas. **`noImplicitThis`** (TS 2.0) genera un error cuando `this` tiene un tipo `any` impl√≠cito. **`useUnknownInCatchVariables`** (TS 4.4) tipifica las variables de las cl√°usulas catch como `unknown` en lugar de `any`. **`alwaysStrict`** (TS 2.1) emite JavaScript en strict mode. Y la adici√≥n m√°s reciente, **`strictBuiltinIteratorReturn`** (TS 5.6), asegura que los iteradores integrados usen `undefined` en lugar de `any` para su tipo de retorno.

Pero `strict: true` deja brechas cr√≠ticas. Matt Pocock, el educador de TypeScript m√°s destacado y autor de Total TypeScript, lo expres√≥ sin rodeos en un tuit de abril de 2024 que gener√≥ m√°s de 102,000 visualizaciones: **"Si no usas `strict: true` en tu tsconfig.json, no est√°s usando TypeScript."** Luego fue m√°s lejos, argumentando que varios flags excluidos de `strict` deber√≠an considerarse esenciales. Los tres m√°s importantes son:

**`noUncheckedIndexedAccess`** (TS 4.1) es posiblemente el flag m√°s valioso que no est√° en `strict`. Sin √©l, `arr[0]` sobre un `string[]` devuelve `string` ‚Äî incluso si el array est√° vac√≠o. Con √©l, el tipo de retorno se convierte en `string | undefined`, oblig√°ndote a manejar ese caso. Pocock dice que este flag "deber√≠a estar incluido en strict."

```typescript
// Sin noUncheckedIndexedAccess ‚Äî INSEGURO
const users: string[] = [];
const first = users[0]; // tipo: string ‚Äî ¬°pero es undefined en tiempo de ejecuci√≥n! üí•
first.toUpperCase();     // Crash en tiempo de ejecuci√≥n, sin error del compilador

// Con noUncheckedIndexedAccess ‚Äî SEGURO
const first = users[0]; // tipo: string | undefined ‚úÖ
first?.toUpperCase();    // Hay que manejar el caso undefined
```

**`exactOptionalPropertyTypes`** (TS 4.4) distingue entre una propiedad ausente y una propiedad expl√≠citamente establecida como `undefined`. Esto importa para APIs donde `"key" in obj` y `obj.key !== undefined` deber√≠an comportarse de forma diferente:

```typescript
interface Settings {
  colorTheme?: "dark" | "light";
}
const s: Settings = { colorTheme: undefined }; // ‚ùå Error con exactOptionalPropertyTypes
const s: Settings = {};                        // ‚úÖ La propiedad est√° correctamente ausente
```

**`noPropertyAccessFromIndexSignature`** (TS 4.2) obliga a usar notaci√≥n de corchetes para las propiedades de firmas de √≠ndice, dejando visualmente claro cu√°ndo se accede a una propiedad conocida frente a una din√°mica.

---

## La tsconfig de m√°xima rigurosidad para 2026

TypeScript 5.9 actualiz√≥ `tsc --init` para generar una configuraci√≥n m√°s opinada, y el equipo de TypeScript se ha **comprometido** (issue #62333 en GitHub) a hacer que `--strict` sea el comportamiento por defecto en TypeScript 6.0. Los nuevos valores por defecto de `tsc --init` ahora incluyen `noUncheckedIndexedAccess` y `exactOptionalPropertyTypes`. A continuaci√≥n se presenta la configuraci√≥n de m√°xima rigurosidad recomendada, sintetizada a partir de la direcci√≥n del equipo de TypeScript, la hoja de referencia de Total TypeScript de Matt Pocock, y el paquete comunitario `@tsconfig/strictest`:

```json
{
  "compilerOptions": {
    // Core strict mode (9 flags)
    "strict": true,

    // Beyond-strict type safety (the critical extras)
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noImplicitOverride": true,
    "noFallthroughCasesInSwitch": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "allowUnreachableCode": false,
    "allowUnusedLabels": false,

    // Module safety
    "verbatimModuleSyntax": true,
    "isolatedModules": true,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
    "forceConsistentCasingInFileNames": true,

    // TS 5.8+ (for Node.js native type stripping)
    "erasableSyntaxOnly": true,

    // Environment
    "target": "es2022",
    "module": "nodenext",
    "skipLibCheck": true
  }
}
```

El flag **`erasableSyntaxOnly`**, introducido en TypeScript 5.8, merece atenci√≥n especial. Genera un error en construcciones de TypeScript que producen JavaScript en tiempo de ejecuci√≥n ‚Äî enums, namespaces y parameter properties. Este flag se alinea con la ejecuci√≥n nativa de TypeScript en Node.js (estable desde Node.js 25.2.0, noviembre de 2025), que elimina las anotaciones de tipo en tiempo de ejecuci√≥n pero no puede manejar sintaxis que requiere generaci√≥n de c√≥digo. Habilitar `erasableSyntaxOnly` te orienta hacia el futuro de TypeScript: una capa de tipos pura sobre JavaScript con cero huella en tiempo de ejecuci√≥n.

**`verbatimModuleSyntax`** (TS 5.0) elimina la ambig√ºedad en las importaciones al requerir `import type` expl√≠cito para las importaciones de solo tipos. Esto evita que TypeScript elida silenciosamente importaciones que podr√≠an tener efectos secundarios y produce una salida de compilaci√≥n predecible en todos los bundlers. **`noUncheckedSideEffectImports`** (TS 5.6) complementa esto generando un error cuando las importaciones de efectos secundarios como `import "module"` no se pueden resolver ‚Äî capturando errores tipogr√°ficos y declaraciones ambientales faltantes.

---

## TypeScript 5.7 y 5.8 elevaron el list√≥n de la rigurosidad

**TypeScript 5.7** (noviembre de 2024) introdujo la detecci√≥n de variables que se declaran pero **nunca se asignan en ning√∫n lugar** dentro del alcance ‚Äî anteriormente, solo las variables *posiblemente* no inicializadas generaban errores. Tambi√©n a√±adi√≥ `--rewriteRelativeImportExtensions` para escribir importaciones `.ts` que compilan a `.js`, y **soporte de cach√© de compilaci√≥n de V8** que entrega **un inicio 2-3x m√°s r√°pido** en proyectos grandes.

**TypeScript 5.8** (marzo de 2025) introdujo dos mejoras significativas de rigurosidad. Primero, **verificaci√≥n granular de ramas en expresiones de retorno**: TypeScript ahora eval√∫a cada rama de las expresiones ternarias en las sentencias `return` de forma independiente contra el tipo de retorno declarado. Anteriormente, si una rama devolv√≠a `any` (algo com√∫n con `Map.get()`), el `any` infectaba la uni√≥n y enmascaraba errores en otras ramas:

```typescript
declare const cache: Map<any, any>;

function getUrl(value: string): URL {
  return cache.has(value) ? cache.get(value) : value;
  //                                           ~~~~~
  // ‚ùå NUEVO en 5.8: Type 'string' is not assignable to 'URL'
  // Anteriormente SIN error porque any | string se simplificaba a any
}
```

Segundo, TypeScript 5.8 a√±adi√≥ el flag **`erasableSyntaxOnly`** y **`--module node18`** como opci√≥n de m√≥dulo estable (no deslizante). La versi√≥n tambi√©n habilit√≥ que los m√≥dulos CommonJS puedan usar `require()` con ESM bajo `--module nodenext`, igualando el comportamiento de Node.js 22+ y reduciendo la necesidad de publicaci√≥n dual.

**TypeScript 6.0** (beta el 11 de febrero de 2026) es la versi√≥n puente hacia el TypeScript 7.0 basado en Go. A√±ade tipos de la API Temporal, mejoras de inferencia, soporte del objetivo ES2025, y un flag `--stableTypeOrdering` para alinear la salida con el comportamiento determinista de TypeScript 7.0. De forma cr√≠tica, TypeScript 6.0 es el **√∫ltimo lanzamiento basado en JavaScript** ‚Äî solo seguir√°n parches de seguridad. TypeScript 7.0, escrito en Go, promete **compilaciones 8-10x m√°s r√°pidas** y mayor capacidad de respuesta del editor en proyectos reales.

---

## Patrones de producci√≥n que el strict mode hace posibles

El strict mode no consiste solo en detectar errores ‚Äî habilita patrones arquitect√≥nicos que ser√≠an inseguros o sin sentido sin √©l. Estos patrones representan las mejores pr√°cticas actuales en bases de c√≥digo TypeScript de producci√≥n.

**Los discriminated unions reemplazan a los enums** en las bases de c√≥digo que priorizan el strict mode. A diferencia de los enums, que generan JavaScript en tiempo de ejecuci√≥n y no pueden llevar datos asociados por variante, los discriminated unions proporcionan coincidencia de patrones exhaustiva con cero costo en tiempo de ejecuci√≥n:

```typescript
type ApiState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: Error };

function render<T>(state: ApiState<T>) {
  switch (state.status) {
    case "success": return state.data;  // TS sabe que `data` existe aqu√≠
    case "error":   return state.error; // TS sabe que `error` existe aqu√≠
    // ¬øFalta un caso? La verificaci√≥n de exhaustividad lo detecta en tiempo de compilaci√≥n
  }
}
```

**Los branded types** resuelven el problema del tipado estructural de TypeScript para identificadores de dominio. Sin ellos, un `UserId` y un `OrderId` son ambos `string` e intercambiables libremente ‚Äî una clase de error que el strict mode por s√≠ solo no detecta:

```typescript
type Brand<K, T> = K & { readonly __brand: T };
type UserId  = Brand<string, "UserId">;
type OrderId = Brand<string, "OrderId">;

function getUser(id: UserId): User { /* ... */ }
const orderId = "ord_123" as OrderId;
getUser(orderId); // ‚ùå Error de compilaci√≥n: OrderId is not assignable to UserId
```

**El operador `satisfies`** (TS 4.9) valida que un valor se ajusta a un tipo sin ampliar el tipo inferido ‚Äî lo mejor de ambos mundos entre seguridad de tipos y precisi√≥n de tipos:

```typescript
const routes = {
  home:  { path: "/", component: "Home" },
  about: { path: "/about", component: "About" },
} satisfies Record<string, { path: string; component: string }>;

routes.home.path; // tipo: "/" (literal estrecho, no ampliado a string)
```

**Zod y la validaci√≥n en tiempo de ejecuci√≥n** completan la historia del strict mode. Zod, que **requiere `strict: true`** en tsconfig.json, proporciona una √∫nica fuente de verdad tanto para los tipos en tiempo de compilaci√≥n como para la validaci√≥n en tiempo de ejecuci√≥n ‚Äî esencial para los l√≠mites de API, entradas de formularios y cualquier dato que entre al sistema desde el exterior:

```typescript
const UserSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  role: z.enum(["admin", "editor", "viewer"]),
});
type User = z.infer<typeof UserSchema>; // Tipo derivado del esquema ‚Äî sin duplicaci√≥n

const result = UserSchema.safeParse(untrustedInput);
if (result.success) {
  result.data.email; // Completamente tipado, validado en tiempo de ejecuci√≥n
}
```

---

## Next.js 15 trata el TypeScript estricto como un requisito de primer nivel

Next.js 15 habilita `"strict": true` por defecto en cada nuevo proyecto creado con `create-next-app`. Tambi√©n incluye un **plugin TypeScript personalizado** (`{ "name": "next" }`) que proporciona verificaci√≥n de tipos para Server Components, Client Components y las convenciones del App Router. Las **rutas tipadas**, estables desde Next.js 15.5, generan props `<Link href>` validadas en tiempo de compilaci√≥n a partir de la estructura de tu sistema de archivos ‚Äî un error tipogr√°fico en una cadena de ruta se convierte en un error de TypeScript:

```tsx
// Con typedRoutes: true en next.config.ts
<Link href="/dashbord">Dashboard</Link>
//         ~~~~~~~~~~~ ‚ùå Error de tipo: no hay ruta que coincida con "/dashbord"
```

Next.js 15.5 tambi√©n introdujo **helpers globales de tipos de ruta** (`LayoutProps<'/dashboard'>`, `PageProps<'/users/[id]'>`) que proporcionan slots de rutas paralelas y par√°metros din√°micos completamente tipados sin necesidad de importaciones. La integraci√≥n de TypeScript del framework se extiende a Server Actions con validaci√≥n Zod, `searchParams` y `params` tipados, y variables de entorno tipadas de forma experimental.

Para m√°xima rigurosidad en un proyecto Next.js 15, el `tsconfig.json` por defecto deber√≠a extenderse con `noUncheckedIndexedAccess`, `exactOptionalPropertyTypes`, `noImplicitReturns` y `verbatimModuleSyntax`. Los valores por defecto `skipLibCheck: true` y `moduleResolution: "bundler"` deben mantenerse.

---

## Migrar al strict mode sin detener el desarrollo de funcionalidades

La estrategia probada para bases de c√≥digo grandes es la migraci√≥n incremental ‚Äî cada historia de √©xito, desde Bloomberg hasta Figma o Airbnb, us√≥ adopci√≥n gradual, no una reescritura de golpe.

**La herramienta recomendada es `typescript-strict-plugin`** de Allegro, con m√°s de 132,000 descargas semanales en npm. El enfoque: habilitar `strict: true` globalmente, luego a√±adir `// @ts-strict-ignore` en la parte superior de cada archivo que todav√≠a no cumple. Los nuevos archivos son estrictos por defecto. Los desarrolladores eliminan el comentario de ignorar a medida que corrigen los archivos, asegurando que la base de c√≥digo solo avance hacia la rigurosidad:

```json
{
  "compilerOptions": {
    "strict": true,
    "plugins": [{ "name": "typescript-strict-plugin" }]
  }
}
```

**La migraci√≥n de Figma** de su base de c√≥digo frontend de 1,162 archivos es el caso de estudio m√°s instructivo. Comenzaron con una lista de archivos ya conformes, configuraron VS Code para mostrar errores estrictos en todas partes (incluso en archivos no conformes), y trataron los ciclos de dependencia como unidades at√≥micas. Su ciclo m√°s grande ten√≠a m√°s de 500 archivos. Una vez que hab√≠a m√°s archivos conformes que no conformes, cambiaron de una lista de permitidos a una lista de bloqueados, haciendo que los nuevos archivos sean estrictos por defecto. La conclusi√≥n clave de los ingenieros de Figma: "El mayor beneficio fue la mayor legibilidad de nuestro c√≥digo. Las partes donde TypeScript ten√≠a m√°s dificultades para inferir la nulabilidad eran a menudo las que eran dif√≠ciles de razonar para los *humanos* ‚Äî y se beneficiaron m√°s de la refactorizaci√≥n."

Para equipos que prefieren la aplicaci√≥n a nivel de commit, **`ts-strictify`** se ejecuta como un hook pre-commit, verificando solo los archivos modificados. El paquete **`@betterer/typescript`** adopta un enfoque de trinquete: toma una instant√°nea del recuento actual de errores y falla en CI si el recuento aumenta. Al habilitar sub-flags de strict de forma incremental sin herramientas, el orden recomendado es: `strictBindCallApply` y `alwaysStrict` primero (victorias f√°ciles), luego `noImplicitAny` (esfuerzo moderado), y `strictNullChecks` al final (genera la mayor cantidad de errores en bases de c√≥digo grandes, a menudo miles).

---

## La evidencia sobre el strict mode y los errores es matizada pero convincente

La estad√≠stica m√°s citada en la defensa de TypeScript es la afirmaci√≥n de Airbnb de que **el 38% de los errores de producci√≥n podr√≠an haberse prevenido con TypeScript**, presentada por Brie Bunge en JSConf Hawaii 2019 a partir del an√°lisis de post-mortems. AWS cit√≥ posteriormente esta cifra en la documentaci√≥n de su SDK v3. La l√≠nea de base acad√©mica proviene del estudio de Gao et al. en ICSE 2017 "To Type or Not to Type", que encontr√≥ que **~el 15% de los errores de JavaScript podr√≠an ser detectados por el sistema de tipos de TypeScript** ‚Äî una cifra que los autores calificaron de estimaci√≥n conservadora, ya que solo contaba los errores que sobreviv√≠an a las pruebas y la revisi√≥n de c√≥digo.

Un estudio de 2022 de Bogner y Merkel analizando **604 proyectos de GitHub** (16 millones de l√≠neas de c√≥digo) encontr√≥ que los proyectos de TypeScript exhib√≠an **significativamente mejor calidad de c√≥digo** (menos code smells) y **mejor comprensibilidad** (menor complejidad cognitiva), pero ‚Äî de forma crucial ‚Äî **la propensi√≥n a errores y el tiempo de resoluci√≥n no eran significativamente menores**. El hallazgo m√°s relevante del estudio para los defensores del strict mode: **reducir el uso de `any` estaba significativamente correlacionado con mejores m√©tricas de calidad de c√≥digo, comprensibilidad y tiempo de resoluci√≥n de errores** (rho de Spearman 0.17‚Äì0.26). Un estudio de 2025 encontr√≥ que **los errores relacionados con tipos cayeron de ~33% en JavaScript a 12.4% en TypeScript**, aunque surgieron nuevas categor√≠as de errores relacionadas con herramientas y configuraci√≥n.

La historia de adopci√≥n de Bloomberg proporciona la evidencia empresarial m√°s s√≥lida: m√°s de 50 millones de l√≠neas de c√≥digo, m√°s de 2,000 ingenieros, strict mode habilitado por defecto en toda su cadena de herramientas. Su m√©trica m√°s reveladora: "M√°s de **200 proyectos optaron por TypeScript en el primer a√±o. Cero proyectos dieron marcha atr√°s.**" La startup WisdomCircle report√≥ una "reducci√≥n significativa en las tasas de error" tras la migraci√≥n al modo estricto, con mayor confianza de los desarrolladores para lanzar funcionalidades.

Los contraargumentos merecen ser considerados con rigor. Eric Elliott argumenta que la reducci√≥n del 15% en errores est√° sobredimensionada cuando ya se aplican otras medidas de calidad (TDD, revisi√≥n de c√≥digo, revisi√≥n de dise√±o), se√±alando que ~78% de los errores son errores de especificaci√≥n que ning√∫n sistema de tipos puede detectar. La famosa objeci√≥n de DHH ‚Äî "Las cosas que deber√≠an ser f√°ciles se vuelven dif√≠ciles, y las cosas dif√≠ciles se convierten en `any`" ‚Äî llev√≥ a Turbo 8 a abandonar TypeScript completamente en septiembre de 2023, aunque esto sigue siendo una posici√≥n minoritaria.

---

## El debate sobre el strict mode tiene un ganador claro

La comunidad ha resuelto en gran medida el debate sobre el strict mode, aunque persisten focos de resistencia. **TypeScript 6.0 habilitar√° `--strict` por defecto** ‚Äî el propio encuadre del equipo de TypeScript dice que "para la mayor√≠a de los proyectos nuevos, tener `--strict` desactivado parece generalmente un accidente." La posici√≥n de Matt Pocock de que todo el ecosistema TypeScript de c√≥digo abierto est√° construido sobre el strict mode ‚Äî "todas las librer√≠as principales est√°n escritas con el strict mode en mente; optar por no usarlo causar√° errores de tipo aleatorios" ‚Äî se ha convertido en el consenso generalizado.

El campo de "el strict mode no es suficientemente estricto" aboga por ir m√°s lejos. Cyrille Tuzi se√±ala que el strict mode todav√≠a permite tipos `any` expl√≠citos y aboga por combinar `strict: true` con la regla de ESLint `@typescript-eslint/no-explicit-any`. El equipo de TypeScript experiment√≥ con un flag `--strictAny` pero lo archiv√≥ ‚Äî Ryan Cavanaugh, el desarrollador principal de TypeScript, reconoci√≥ querer un manejo m√°s estricto de `any` "alrededor del 50% de las veces", pero encontr√≥ que el otro 50% necesitaba la v√≠a de escape.

La dimensi√≥n de la IA fortalece de forma decisiva el argumento del strict mode. El Octoverse 2025 de GitHub vincula expl√≠citamente el auge de contribuyentes de TypeScript con la programaci√≥n asistida por IA. Con **el 94% de los errores de compilaci√≥n generados por LLMs siendo fallos de verificaci√≥n de tipos**, el TypeScript estricto act√∫a como una capa de verificaci√≥n para el c√≥digo generado por IA. Los equipos con tipado s√≥lido y patrones claros reportan las mayores ganancias de fiabilidad al usar herramientas de IA. A medida que la IA escribe m√°s c√≥digo, el sistema de tipos se convierte menos en una herramienta para detectar errores humanos y m√°s en una restricci√≥n para la salida de las m√°quinas ‚Äî una propuesta de valor fundamentalmente diferente que favorece la m√°xima rigurosidad.

---

## Conclusi√≥n

El argumento de que la dominancia de TypeScript est√° ligada a la seguridad de tipos estricta descansa en evidencia convergente: el punto de dolor #1 en las encuestas de JavaScript siempre es la falta de tipos, el lenguaje m√°s usado en GitHub es TypeScript, todos los frameworks principales incluyen strict mode por defecto, las herramientas de codificaci√≥n con IA dependen de los tipos como barandillas, y el propio equipo de TypeScript est√° haciendo el strict mode el comportamiento por defecto. La implicaci√≥n pr√°ctica es clara. Habilita `strict: true`. A√±ade `noUncheckedIndexedAccess`, `exactOptionalPropertyTypes` y `verbatimModuleSyntax`. Usa discriminated unions en lugar de enums, branded types para identificadores de dominio, Zod para los l√≠mites en tiempo de ejecuci√≥n, y `satisfies` para los objetos de configuraci√≥n. Migra de forma incremental con `typescript-strict-plugin`. Las herramientas, el ecosistema y los datos apuntan todos en una direcci√≥n: **el TypeScript estricto no es una preferencia de estilo ‚Äî es la l√≠nea de base que le vali√≥ la victoria a TypeScript.**
